
-- Add attachments column to tasks table
alter table public.tasks
add column attachments jsonb;

-- Create the app_settings table
create table if not exists public.app_settings (
  id bigint generated by default as identity primary key,
  key text not null unique,
  value jsonb
);
-- RLS for app_settings
alter table public.app_settings enable row level security;
create policy "Allow all access to app_settings" on public.app_settings for all using (true) with check (true);

-- Enable pg_cron extension
create extension if not exists pg_cron with schema extensions;

-- Grant usage of the cron schema to the postgres user
grant usage on schema cron to postgres;
grant all on all tables in schema cron to postgres;

-- delete_task_attachments function
create or replace function public.delete_task_attachments(task_id uuid)
returns void
language plpgsql
as $$
declare
  attachments_to_delete jsonb;
  attachment_path text;
begin
  -- Get the attachments for the given task
  select attachments into attachments_to_delete from public.tasks where id = task_id;

  -- If there are attachments, loop through and delete them from storage
  if attachments_to_delete is not null then
    for attachment_path in select value->>'path' from jsonb_array_elements(attachments_to_delete)
    loop
      -- storage.delete_object returns an array of deleted objects.
      -- We don't need to check the result for this use case.
      perform storage.delete_object('attachments', attachment_path);
    end loop;

    -- Clear the attachments column in the tasks table
    update public.tasks
    set attachments = null
    where id = task_id;
  end if;
end;
$$;


-- handle_task_done function
create or replace function public.handle_task_done()
returns trigger
language plpgsql
as $$
declare
  delay_seconds int;
  job_name text;
begin
  job_name := 'delete-attachments-' || NEW.id::text;

  -- Task is marked as "Done"
  if NEW.status = 'done' and (OLD is null or OLD.status <> 'done') then
    -- Get deletion delay from settings, default to 300 seconds (5 minutes)
    select coalesce(
      (select value from public.app_settings where key = 'attachment_deletion_delay' limit 1)::int,
      300
    ) into delay_seconds;

    -- Schedule deletion only if there are attachments and delay is positive
    if NEW.attachments is not null and delay_seconds > 0 then
       perform cron.schedule(
        job_name,
        (now() + (delay_seconds || ' seconds')::interval)::text,
        format('select public.delete_task_attachments(%L)', NEW.id)
      );
    end if;

  -- Task status is changed from "Done" to something else
  elsif OLD.status = 'done' and NEW.status <> 'done' then
    -- Cancel the scheduled deletion job
    perform cron.unschedule(job_name);
  end if;

  return NEW;
end;
$$;

-- Create or replace the trigger on the tasks table
drop trigger if exists on_task_status_change on public.tasks;
create trigger on_task_status_change
  after update on public.tasks
  for each row
  execute function public.handle_task_done();


-- Grant execute on functions to the authenticated role
grant execute on function public.delete_task_attachments(uuid) to authenticated;
grant execute on function public.handle_task_done() to authenticated;


-- update_task_status function
create or replace function public.update_task_status(task_id uuid, new_status text)
returns void
language plpgsql
as $$
begin
  update public.tasks
  set status = new_status::public.task_status
  where id = task_id;
end;
$$;

-- Grant execute on the new function
grant execute on function public.update_task_status(uuid, text) to authenticated;
