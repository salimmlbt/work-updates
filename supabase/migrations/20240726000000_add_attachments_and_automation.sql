
-- Enable pg_cron if not already enabled
create extension if not exists pg_cron with schema extensions;

-- Grant usage of the cron schema to supabase_admin
grant usage on schema cron to supabase_admin;
-- Grant all privileges on all tables in the cron schema to supabase_admin
grant all privileges on all tables in schema cron to supabase_admin;

-- Add attachments column to tasks table
alter table public.tasks
add column if not exists attachments jsonb;

-- Create app_settings table for deletion delay
create table if not exists public.app_settings (
    id bigint generated by default as identity primary key,
    key text unique not null,
    value jsonb
);
alter table public.app_settings enable row level security;
create policy "Allow all access to app_settings" on public.app_settings for all using (true) with check (true);

-- Insert default deletion delay (300 seconds = 5 minutes)
insert into public.app_settings (key, value)
values ('attachment_deletion_delay', '300')
on conflict (key) do nothing;


-- Function to delete attachments from storage
create or replace function public.delete_task_attachments(task_id uuid)
returns void
language plpgsql
security definer set search_path = public
as $$
declare
    attachment jsonb;
    file_path text;
begin
    -- Get attachments for the given task
    select attachments into attachment
    from tasks
    where id = task_id;

    -- If attachments exist, loop through and delete them from storage
    if attachment is not null then
        for attachment in select * from jsonb_array_elements(attachment)
        loop
            file_path := attachment->>'path';
            if file_path is not null then
                perform storage.delete_object('attachments', file_path);
            end if;
        end loop;
    end if;
end;
$$;


-- Create a trigger function to schedule or unschedule deletion
create or replace function public.handle_task_completion_for_attachments()
returns trigger
language plpgsql
security definer set search_path = public
as $$
declare
    task_id uuid;
    deletion_delay_seconds int;
    job_name text;
begin
    if TG_OP = 'UPDATE' then
        task_id := new.id;
        job_name := 'delete-attachments-' || task_id::text;

        -- Get the delay from app_settings, default to 300 seconds (5 minutes)
        select value::int into deletion_delay_seconds
        from app_settings
        where key = 'attachment_deletion_delay'
        limit 1;

        if not found then
            deletion_delay_seconds := 300;
        end if;

        -- If task is marked as 'done'
        if new.status = 'done' and old.status <> 'done' then
            -- Schedule a new deletion job
            perform cron.schedule(
                job_name,
                (now() + (deletion_delay_seconds || ' seconds')::interval)::text,
                $$ select public.delete_task_attachments('$$ || task_id::text || $$') $$
            );
        -- If task is moved out of 'done'
        elsif new.status <> 'done' and old.status = 'done' then
            -- Cancel the deletion job
            perform cron.unschedule(job_name);
        end if;
    end if;

    return new;
end;
$$;

-- Drop existing trigger before creating a new one to avoid duplication
drop trigger if exists on_task_completion_attachments on public.tasks;

-- Create the trigger on the tasks table
create trigger on_task_completion_attachments
after update on public.tasks
for each row
execute function public.handle_task_completion_for_attachments();
