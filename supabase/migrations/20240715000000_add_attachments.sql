
-- Add attachments column to tasks table
alter table tasks add column attachments jsonb;

-- Create app_settings table
create table if not exists app_settings (
    id bigint generated by default as identity primary key,
    key text unique not null,
    value jsonb
);

-- Set default attachment deletion delay to 5 minutes (300 seconds)
insert into app_settings (key, value)
values ('attachment_deletion_delay', '300')
on conflict (key) do nothing;

-- Enable pg_cron if not already enabled
create extension if not exists pg_cron with schema extensions;

-- Grant usage of pg_cron to the postgres user
grant usage on schema cron to postgres;
grant all privileges on all tables in schema cron to postgres;

-- Create a function to handle task status updates and schedule/cancel deletions
create or replace function public.update_task_status(task_id uuid, new_status text)
returns void as $$
declare
  current_task public.tasks;
  deletion_delay_seconds int;
begin
  -- Get the current task details
  select * into current_task from public.tasks where id = task_id;

  -- If status is not changing, do nothing
  if current_task.status = new_status then
    return;
  end if;

  -- Cancel any existing cron job for this task
  perform cron.unschedule(job_name := 'delete_attachments_' || task_id::text);

  -- Update the task status
  update public.tasks set status = new_status where id = task_id;

  -- If new status is 'done' and there are attachments, schedule a deletion job
  if new_status = 'done' and current_task.attachments is not null and jsonb_array_length(current_task.attachments) > 0 then
    -- Get deletion delay from settings, default to 300 seconds (5 minutes)
    select (value::text)::int into deletion_delay_seconds from public.app_settings where key = 'attachment_deletion_delay';
    if not found then
        deletion_delay_seconds := 300;
    end if;
    
    perform cron.schedule(
      job_name := 'delete_attachments_' || task_id::text,
      schedule := (now() + (deletion_delay_seconds || 300) * interval '1 second')::text,
      command := $$
        select public.delete_task_attachments(task_id := '$$ || task_id::text || $$');
      $$
    );
  end if;

end;
$$ language plpgsql security definer;

-- Create a function that will be called by the cron job to delete files
create or replace function public.delete_task_attachments(task_id uuid)
returns void as $$
declare
  attachment_paths text[];
  current_task public.tasks;
begin
  -- Ensure task is still 'done'
  select * into current_task from public.tasks where id = task_id;

  if current_task.status = 'done' and current_task.attachments is not null then
    -- Extract file paths from the attachments jsonb
    select array_agg(path) into attachment_paths
    from jsonb_to_recordset(current_task.attachments) as x(path text);
    
    if array_length(attachment_paths, 1) > 0 then
        -- Delete files from storage
        perform storage.delete_objects('attachments', attachment_paths);
        
        -- Clear the attachments column
        update public.tasks set attachments = null where id = task_id;
    end if;
  end if;
end;
$$ language plpgsql security definer;

-- Grant execute on functions to authenticated users
grant execute on function public.update_task_status(uuid, text) to authenticated;
grant execute on function public.delete_task_attachments(uuid) to postgres; -- Only callable by the cron job which runs as postgres

-- Create policies for app_settings
alter table public.app_settings enable row level security;
create policy "Allow full access to admin users" on public.app_settings for all using ( (select auth.uid() in (select id from profiles where role_id in (select id from roles where name = 'Falaq Admin')))) with check ( (select auth.uid() in (select id from profiles where role_id in (select id from roles where name = 'Falaq Admin'))));
create policy "Allow read access to authenticated users" on public.app_settings for select to authenticated using (true);
